第1章 基础知识

1.1 简单说明如何选择正确的Python版本。

答：

在选择Python的时候，一定要先考虑清楚自己学习Python的目的是什么，打算做哪方面的开发，有哪些扩展库可用，这些扩展库最高支持哪个版本的Python，是Python 2.x还是Python 3.x，最高支持到Python 2.7.6还是Python 2.7.9还是Python 2.7.11。这些问题都确定以后，再做出自己的选择，这样才能事半功倍，而不至于把大量时间浪费在Python的反复安装和卸载上。同时还应该注意，当更新的Python版本推出之后，不要急于更新，而是应该等确定自己所必须使用的扩展库也推出了较新版本之后再进行更新。

尽管如此，Python 3毕竟是大势所趋，如果您暂时还没想到要做什么行业领域的应用开发，或者仅仅是为了尝试一种新的、好玩的语言，那么请毫不犹豫地选择Python 3.x系列的最高版本（目前是[Python 3.6.1](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=Python+3.6.1&zhida_source=entity)）。

1.2 为什么说Python采用的是[基于值的内存管理模式](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=基于值的内存管理模式&zhida_source=entity)？

答：

Python采用的是基于值的内存管理方式，如果为不同变量赋值相同值，则在内存中只有一份该值，多个变量指向同一块内存地址，例如下面的代码。

\>>> x = 3

\>>> id(x)

10417624

\>>> y = 3

\>>> id(y)

10417624

\>>> y = 5

\>>> id(y)

10417600

\>>> id(x)

10417624

1.3 解释Python中的运算符/和//的区别。

答：

在Python中/表示普通除法（也叫真除法），其结果是实数，而//表示[整除](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=整除&zhida_source=entity)，得到的结果是整数，并且自动向下取整。

1.4  在Python中[导入模块](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=导入模块&zhida_source=entity)中的对象有哪几种方式？

答：常用的有三种方式，分别为

import 模块名 [as 别名]

from 模块名 import 对象名[ as 别名]

from math import *

1.5  ______________是目前比较常用的Python扩展库管理工具。（pip）

1.6  解释Python脚本程序的[__name__变量](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=__name__变量&zhida_source=entity)及其作用。

答：

每个Python程序都有一个__name__变量，用来表示程序的运行方式。当作为模块导入时，__name__变量的值等于程序文件名，当直接运行程序时其值为字符串’__main__’。

1.7  运算符%________（可以、不可以）对浮点数进行求余数操作。（可以）

1.8  一个数字5___________（是、不是）合法的Python表达式。（是）

1.9  在Python 2.x中，input()函数接收到的数据类型由_________确定，而在Python3.x中该函数则认为接收到的用户输入数据一律为________。（界定符、字符串）

1.10 编写程序，用户输入一个三位以上的整数，输出其百位以上的数字。例如用户输入1234，则程序输出12。（提示：使用整除运算。）

答：

x = input('请输入3位以上的数字：')

if len(x) >= 3:

​    x = int(x)

​    print(x // 100)

else:

​    print('输入错误。')



第2章 Python数据结构

2.1  为什么应尽量从列表的尾部进行元素的增加与删除操作？

答：

当列表增加或删除元素时，列表对象自动进行内存扩展或收缩，从而保证元素之间没有缝隙，但这涉及到列表元素的移动，效率较低，应尽量从列表尾部进行元素的增加与删除操作以提高处理速度。

2.2  [range()函数](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=range()函数&zhida_source=entity)在Python 2.x中返回一个___________，而在Python 3.x中的range()函数返回一个___________。（列表、range对象）

2.3  编写程序，生成包含1000个0到100之间的随机整数，并统计每个元素的出现次数。

答：

import random



x = [random.randint(0,100) for i in range(1000)]

\# 使用集合

s = set(x)

for v in s:

​    print(v, ':', x.count(v))

print('='*30)



\# 使用字典

d = dict()

for v in x:

​    d[v] = d.get(v,0) + 1

for k, v in d.items():

​    print(k, v, sep=':')

2.4  表达式“[3] in [1,2,3,4]”的值为___________。（False）

2.5  编写程序，用户输入一个列表和2个整数作为下标，然后输出列表中介于2个下标之间的元素组成的子列表。例如用户输入[1,2,3,4,5,6]和2,5，程序输出[3,4,5,6]。

答：

x = input('Please input a list:')

x = eval(x)

start, end = eval(input('Please input the start position and the end position:'))

print(x[start:end+1])

2.6  列表对象的sort()方法用来对列表元素进行原地排序，该方法的返回值为________。（None）

2.7  列表对象的___________方法删除首次出现的指定元素，如果列表中不存在要删除的元素，则抛出异常。（remove()）

2.8  假设列表对象sList的值为[3, 4, 5, 6, 7, 9, 11, 13, 15, 17]，那么切片aList[3:7]得到的值是_________________。（[6, 7, 9, 11]）

2.9  设计一个字典，并编写程序，用户输入内容作为键，然后输出字典中对应的值，如果用户输入的键不存在，则输出“您输入的键不存在！”

答：

d = {1:'a', 2:'b', 3:'c', 4:'d'}

v = input('Please input a key:')

v = eval(v)

print(d.get(v,'您输入的的键不存在'))

2.10  编写程序，生成包含20个随机数的列表，然后将前10个元素升序排列，后10个元素降序排列，并输出结果。

答：

import random



x = [random.randint(0,100) for i in range(20)]

print(x)



x[:10] = sorted(x[:10])

x[10:] = sorted(x[10:], reverse=True)



print(x)

2.11  在Python中，字典和集合都是用一对          作为定界符，字典的每个元素有两部分组成，即        和        ，其中        不允许重复。（大括号、键、值、键）

2.12  使用字典对象的____________方法可以返回字典的“键-值对”列表，使用字典对象的_________方法可以返回字典的“键”列表，使用字典对象的_____________方法可以返回字典的“值”列表。（items()、keys()、values()）

2.13  假设有列表a = ['name','age','sex']和b = ['Dong',38,'Male']，请使用一个语句将这两个列表的内容转换为字典，并且以列表a中的元素为键，以列表b中的元素为值，这个语句可以写为          。（c = dict(zip(a,b))）

2.14  假设有一个列表a，现要求从列表a中每3个元素取1个，并且将取到的元素组成新的列表b，可以使用语句          。（b = a[::3]）

2.15  使用[列表推导式](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=列表推导式&zhida_source=entity)生成包含10个数字5的列表，语句可以写为_______________。（[5 for i in range(10)]）

2.16  ___________（可以、不可以）使用del命令来删除元组中的部分元素。（不可以）





第3章 选择结构与循环结构

3.1 分析[逻辑运算符“or”的短路求值特性](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=逻辑运算符“or”的短路求值特性&zhida_source=entity)。

答：

假设有表达式“表达式1 or 表达式2”，如果表达式1的值等价于True，那么无论表达式2的值是什么，整个表达式的值总是等价于True。因此，不需要再计算表达式2的值。

3.2 编写程序，运行后用户输入4位整数作为年份，判断其是否为闰年。如果年份能被400整除，则为闰年；如果年份能被4整除但不能被100整除也为闰年。

答：

x = input('Please input an integer of 4 digits meaning the year:')

x = eval(x)

if x%400==0 or (x%4==0 and not x%100==0):

​    print('Yes')

else:

​    print('No')

3.3  Python提供了两种基本的循环结构：_________________和______________。（for循环、while循环）

3.4 编写程序，生成一个包含50个随机整数的列表，然后删除其中所有奇数。（

答：

import random



x = [random.randint(0,100) for i in range(50)]

print(x)



for i in range(len(x))[::-1]:

​    if x[i]%2 == 1:

​        del x[i]

print(x)

3.5  编写程序，生成一个包含20个随机整数的列表，然后对其中偶数下标的元素进行降序排列，奇数下标的元素不变。（提示：使用切片。）

答：

import random



x = [random.randint(0,100) for i in range(20)]

print(x)



x[::2] = sorted(x[::2], reverse=True)

print(x)

3.6 编写程序，用户从键盘输入小于1000的整数，对其进行因式分解。例如，10=2×5，60=2×2×3×5。

答：

x = input('Please input an integer less than 1000:')

x = eval(x)

t = x

i = 2

result = []

while True:

​    if t==1:

​        break

​    if t%i == 0:

​        result.append(i)

​        t = t//i

​    else:

​        i += 1

print(x,'=', '*'.join(map(str,result)))

3.7 编写程序，至少使用2种不同的方法计算100以内所有奇数的和。

答：

print(sum([i for i in range(1,100) if i%2==1]))

print(sum(range(1,100)[::2]))

3.8  编写程序，输出所有由1、2、3、4这4个数字组成的素数，并且在每个素数中每个数字只使用依次。

答：

from itertools import permutations



digits = (1, 2, 3, 4)



def isPrime(n):

​    if n==1:

​        return False

​    if n==2:

​        return True

​    if n%2 == 0:

​        return False

​    for i in range(3, int(n**0.5)+1, 2):

​        if n%i == 0:

​            return False

​    return True



for i in range(1, len(digits)+1):

​    for number in permutations(digits, i):

​        number = int(''.join(map(str, number)))

​        if isPrime(number):

​            print(number)

3.9  编写程序，实现分段函数计算，如下表所示。

x

y



x<0

0



0<=x<5

x



5<=x<10

3x-5



10<=x<20

0.5x-2



20<=x

0



答：

x = input('Please input x:')

x = eval(x)



if 0<=x<5:

​    print(x)

elif 5<=x<10:

​    print(3*x-5)

elif 10<=x<20:

​    print(0.5*x-2)

else:

​    print(0)



第4章 字符串与正则表达式

4.1 假设有一段英文，其中有单独的字母“I”误写为“i”，请编写程序进行纠正。

答：

1）不使用正则表达式

x = "i am a teacher,i am man, and i am 38 years old.I am not a businessman."

x = x.replace('i ','I ')

x = x.replace(' i ',' I ')

print(x)

2）使用正则表达式

import re



x = "i am a teacher,i am man, and i am 38 years old.I am not a businessman."



result = re.sub(r'\bi\b', 'I', x)

print(result)

4.2 假设有一段英文，其中有单词中间的字母“i”误写为“I”，请编写程序进行纠正。

答：

import re



x = "I am a teacher,I am man, and I am 38 years old.I am not a busInessman."

print(x)



result = re.sub(r'\BI\B', 'i', x)

print(result)

4.3 有一段英文文本，其中有单词连续重复了2次，编写程序检查重复的单词并只保留一个。例如文本内容为“This is is a desk.”，程序输出为“This is a desk.”

答：这里给出Python 3.4.2代码，如果使用Python 2.7.8的话只需要修改其中的print()函数为print语句即可。

1）方法一

import re



x = 'This is is a desk.'

pattern = re.compile(r'\b(\w+)(\s+\1){1,}\b')

matchResult = pattern.search(x)

x = pattern.sub(matchResult.group(1),x)

print(x)

2）方法二

import re



x = 'This is is a desk.'

pattern = re.compile(r'(?P<f>\b\w+\b)\s(?P=f)')

matchResult = pattern.search(x)

x = x.replace(matchResult.group(0),matchResult.group(1))

print(x)

4.4 简单解释Python的[字符串驻留机制](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=字符串驻留机制&zhida_source=entity)。

答：

Python支持字符串驻留机制，即：对于短字符串，将其赋值给多个不同的对象时，内存中只有一个副本，多个对象共享该副本。这一点不适用于长字符串，即长字符串不遵守驻留机制，下面的代码演示了短字符串和长字符串在这方面的区别。

\>>> a = '1234'

\>>> b = '1234'

\>>> id(a) == id(b)

True

\>>> a = '1234'*50

\>>> b = '1234'*50

\>>> id(a) == id(b)

False

4.5 编写程序，用户输入一段英文，然后输出这段英文中所有长度为3个字母的单词。

答：

import re



x = input('Please input a string:')

pattern = re.compile(r'\b[a-zA-Z]{3}\b')

print(pattern.findall(x))



第5章 函数设计与使用

5.1 运行5.3.1小节最后的示例代码，查看结果并分析原因。

答：原因是对于函数的默认值参数只会被处理一次，下次再调用函数并且不为默认值参数赋值时会继续使用上一次的结果，对于列表这样的结构，如果调用函数时为默认值参数的列表插入或删除了元素，将会得到保留，从而影响下一次调用。

5.2 编写函数，判断一个整数是否为素数，并编写主程序调用该函数。

答：

import math

def IsPrime(v):

​    n = int(math.sqrt(v)+1)

​    for i in range(2,n):

​        if v%i==0:

​            return 'No'

​    else:

​        return 'Yes'



print(IsPrime(37))

print(IsPrime(60))

print(IsPrime(113))

5.3 编写函数，接收一个字符串，分别统计大写字母、小写字母、数字、其他字符的个数，并以元组的形式返回结果。

答：

def demo(v):

​    capital = little = digit = other =0

​    for i in v:

​        if 'A'<=i<='Z':

​            capital+=1

​        elif 'a'<=i<='z':

​            little+=1

​        elif '0'<=i<='9':

​            digit+=1

​        else:

​            other+=1

return (capital,little,digit,other)



x = 'capital = little = digit = other =0'

print(demo(x))

5.4  在函数内部可以通过关键字___________来定义全局变量。（global）

5.5  如果函数中没有return语句或者return语句不带任何返回值，那么该函数的返回值为____________。（None）

5.6  调用带有默认值参数的函数时，不能为默认值参数传递任何值，必须使用函数定义时设置的默认值（判断对错）。（错）

5.7 在Python程序中，局部变量会隐藏同名的全局变量吗？请编写代码进行验证。

答案：会。

\>>> def demo():

​	a=3

​	print a



\>>> a=5

\>>> demo()

3

\>>> a

5

5.8  [lambda表达式](https://zhida.zhihu.com/search?content_id=207309607&content_type=Article&match_order=1&q=lambda表达式&zhida_source=entity)只能用来创建匿名函数，不能为这样的函数起名字（判断对错）。（错）

5.9 编写函数，可以接收任意多个整数并输出其中的最大值和所有整数之和。

答：

def demo(*v):

​    print(v)

​    print(max(v))

print(sum(v))



demo(1,2,3)

demo(1,2,3,4)

demo(1,2,3,4,5)

5.10  编写函数，模拟内置函数sum()。

答：

def Sum(v):

​    s = 0

​    for i in v:

​        s += i

return s



x = [1,2,3,4,5]

print(Sum(x))

x = (1,2,3,4,5)

print(Sum(x))



5.11  包含_________语句的函数可以用来创建生成器对象。（yield）

5.12  编写函数，模拟内置函数sorted()。

答：

from random import randint



def mySorted(lst, reverse=False):

​    lst = lst[:]

​    length = len(lst)

​    for i in range(0, length):

​        flag = False

​        for j in range(0, length-i-1):

​            \#比较相邻两个元素大小，并根据需要进行交换

​            \#默认升序排序

​            exp = 'lst[j] > lst[j+1]'

​            \#如果reverse=True则降序排序

​            if reverse:

​                exp = 'lst[j] < lst[j+1]'

​            if eval(exp):

​                lst[j], lst[j+1] = lst[j+1], lst[j]

​                \#flag=True表示本次扫描发生过元素交换

​                flag = True

​        \#如果一次扫描结束后，没有发生过元素交换，说明已经按序排列

​        if not flag:

​            break

​    return lst



lst = [randint(1, 100) for i in range(20)]

print('Before sorted:\n', lst)

print('After sorted:\n', mySorted(lst, True))



第6章 面向对象程序设计

6.1  继承6.5节例6-2中的Person类生成Student类，填写新的函数用来设置学生专业，然后生成该类对象并显示信息。

答：

import types



class Person(object): #基类必须继承于object，否则在派生类中将无法使用super()函数

​    def __init__(self, name = '', age = 20, sex = 'man'):

​        self.setName(name)

​        self.setAge(age)

​        self.setSex(sex)

​    def setName(self, name):

​        if not isinstance(name,str):

​            print('name must be string.')

​            return

​        self.__name = name

​    def setAge(self, age):

​        if not isinstance(age,int):

​            print('age must be integer.')

​            return

​        self.__age = age

​    def setSex(self, sex):

​        if sex != 'man' and sex != 'woman':

​            print('sex must be "man" or "woman"')

​            return

​        self.__sex = sex

​    def show(self):

​        print(self.__name)

​        print(self.__age)

​        print(self.__sex)



class Student(Person):

​    def __init__(self, name='', age = 30, sex = 'man', major = 'Computer'):

​        \#调用基类构造方法初始化基类的私有数据成员

​        super(Student, self).__init__(name, age, sex)

​        self.setMajor(major) #初始化派生类的数据成员

​    def setMajor(self, major):

​        if not isinstance(major, str):

​            print('major must be a string.')

​            return

​        self.__major = major

​    def show(self):

​        super(Student, self).show()

​        print(self.__major)



if __name__ =='__main__':

​    zhangsan = Person('Zhang San', 19, 'man')

​    zhangsan.show()

​    lisi = Student('Li Si',32, 'man', 'Math')

​    lisi.show()

6.2  设计一个三维向量类，并实现向量的加法、减法以及向量与标量的乘法和除法运算。

答：

class Vecter3:

​    def __init__(self, x=0, y=0, z=0):

​        self.X = x

​        self.Y = y

​        self.Z = z



​    def __add__(self, n):

​        r = Vecter3()

​        r.X = self.X + n.X

​        r.Y = self.Y + n.Y

​        r.Z = self.Z + n.Z

​        return r



​    def __sub__(self, n):

​        r = Vecter3()

​        r.X = self.X - n.X

​        r.Y = self.Y - n.Y

​        r.Z = self.Z - n.Z

​        return r



​    def __mul__(self, n):

​        r = Vecter3()

​        r.X = self.X * n

​        r.Y = self.Y * n

​        r.Z = self.Z * n

​        return r



​    def __truediv__(self, n):

​        r = Vecter3()

​        r.X = self.X / n

​        r.Y = self.Y / n

​        r.Z = self.Z / n

​        return r



​    def __floordiv__(self, n):

​        r = Vecter3()

​        r.X = self.X // n

​        r.Y = self.Y // n

​        r.Z = self.Z // n

​        return r



​    def show(self):

​        print((self.X,self.Y,self.Z))



v1 = Vecter3(1,2,3)

v2 = Vecter3(4,5,6)

v3 = v1+v2

v3.show()

v4 = v1-v2

v4.show()

v5 = v1*3

v5.show()

v6 = v1/2

v6.show()

6.3  面向对象程序设计的三要素分别为        、         和       。（封装、继承、多态）

6.4  简单解释Python中以下划线开头的变量名特点。

答：

在Python中，以下划线开头的变量名有特殊的含义，尤其是在类的定义中。用下划线作为变量前缀和后缀来表示类的特殊成员：

_xxx：这样的对象叫做保护变量，不能用'from module import *'导入，只有类对象和子类对象能访问这些变量；

__xxx__：系统定义的特殊成员名字；

__xxx：类中的私有成员，只有类对象自己能访问，子类对象也不能访问到这个成员，但在对象外部可以通过“对象名._类名__xxx”这样的特殊方式来访问。Python中没有纯粹的C++意义上的私有成员。

6.5  与运算符“**”对应的特殊方法名为________，与运算符“//”对应的特殊方法名为____________。（__pow__()、__floordiv__()）

6.6  假设a为类A的对象且包含一个私有数据成员“__value”，那么在类的外部通过对象a直接将其私有数据成员“__value”的值设置为3的语句可以写作___________。（a._A__value = 3）



第7章 文件操作

7.1 假设有一个英文文本文件，编写程序读取其内容，并将其中的大写字母变为小写字母，小写字母变为大写字母。

答：

with open(r'd:\1.txt','r') as src, open(r'd:2.txt', 'w') as dst:

​    for line in src:

​        dst.write(line.swapcase())

7.2 编写程序，将包含学生成绩的字典保存为二进制文件，然后再读取内容并显示。

答：

import pickle



score = {'张三':98,'李四':90,'王五':100}



with open('score.dat','wb') as fp:

​    pickle.dump(score,fp)



with open('score.dat','rb') as fp:

​    result = pickle.load(fp)



print(result)

7.3 使用shutil模块中的move()方法进行文件移动。

答：

\>>> import shutil

\>>> shutil.move(r'd:\1.txt', r'e:\1.txt')

'e:\\1.txt'

7.4 简单解释文本文件与二进制文件的区别。

答：

（1）文本文件

文本文件存储的是常规字符串，由若干文本行组成，通常每行以换行符'\n'结尾。常规字符串是指记事本或其他文本编辑器能正常显示、编辑并且人类能够直接阅读和理解的字符串，如英文字母、汉字、数字字符串。文本文件可以使用字处理软件如gedit、记事本进行编辑。

（2）二进制文件

二进制文件把对象内容以字节串(bytes)进行存储，无法用记事本或其他普通字处理软件直接进行编辑，通常也无法被人类直接阅读和理解，需要使用专门的软件进行解码后读取、显示、修改或执行。常见的如图形图像文件、音视频文件、可执行文件、资源文件、各种数据库文件、各类office文档等都属于二进制文件。

7.5 编写代码，将当前工作目录修改为“c:\”，并验证，最后将当前工作目录恢复为原来的目录。

答：

\>>> import os

\>>> os.getcwd()

'C:\\Python35'

\>>> os.chdir(r'c:\\')

\>>> os.getcwd()

'c:\\'

\>>> os.chdir(r'c:\Python35')

\>>> os.getcwd()

'c:\\Python35'

7.6 编写程序，用户输入一个目录和一个文件名，搜索该目录及其子目录中是否存在该文件。

答：

import sys

import os



directory = sys.argv[1]

filename = sys.argv[2]



paths = os.walk(directory)

for root,dirs,files in paths:    

​    if filename in files:

​        print('Yes')

​        break

else:

print('No')

7.7  文件对象的________方法用来把缓冲区的内容写入文件，但不关闭文件。（flush()）

7.8  os.path模块中的_________方法用来测试指定的路径是否为文件。（isfile()）

7.9  os模块的_________方法用来返回包含指定文件夹中所有文件和子文件夹的列表。（listdir()）



第8章 异常处理结构与程序调试

8.1 Python异常处理结构有哪几种形式？

答：

比较常用的形式有：

1）标准异常处理结构

try:

​	try块 #被监控的语句，可能会引发异常

except Exception[as reason]:

​	except块	 #处理异常的代码

如果需要捕获所有异常时，可以使用BaseException，代码格式如下：

try:

​	……

except BaseException as e: 

​	except块	#处理所有错误 

上面的结构可以捕获所有异常，尽管这样做很安全，但是一般并不建议这样做。对于异常处理结构，一般的建议是尽量显式捕捉可能会出现的异常并且有针对性地编写代码进行处理，因为在实际应用开发中，很难使用同一段代码去处理所有类型的异常。当然，为了避免遗漏没有得到处理的异常干扰程序的正常执行，在捕捉了所有可能想到的异常之后，您也可以使用异常处理结构的最后一个except来捕捉BaseException。

2）另外一种常用的异常处理结构是try...except...else...语句。

3）在实际开发中，同一段代码可能会抛出多个异常，需要针对不同的异常类型进行相应的处理。为了支持多个异常的捕捉和处理，Python提供了带有多个except的异常处理结构，这类似于多分支选择结构，一旦某个except捕获了异常，则后面剩余的except子句将不会再执行。语法为：

try:

​	try块		    	#被监控的语句

except Exception1:

​	except块1			#处理异常1的语句

except Exception2:

​	except块2			#处理异常2的语句

4）将要捕获的异常写在一个元组中，可以使用一个except语句捕获多个异常，并且共用同一段异常处理代码，当然，除非确定要捕获的多个异常可以使用同一段代码来处理，并不建议这样做。

5）最后一种常用的异常处理结构是try...except...finally...结构。在该结构中，finally子句中的内存无论是否发生异常都会执行，常用来做一些清理工作以释放try子句中申请的资源。语法如下：

try:

​		……

finally:

​	......		#无论如何都会执行的代码

8.2 异常和错误有什么区别？

答：

异常是指因为程序执行过程中出错而在正常控制流以外采取的行为。严格来说，语法错误和逻辑错误不属于异常，但有些语法错误往往会导致异常，例如由于大小写拼写错误而访问不存在的对象，或者试图访问不存在的文件，等等。

8.3 使用pdb模块进行Python程序调试主要有哪几种用法？

答：主要有三种方式，

1）在交互模式下使用pdb模块提供的功能可以直接调试语句块、表达式、函数等多种脚本。

2）在程序中嵌入断点来实现调试功能

在程序中首先导入pdb模块，然后使用pdb.set_trace()在需要的位置设置断点。如果程序中存在通过该方法调用显式插入的断点，那么在命令提示符环境下执行该程序或双击执行程序时将自动打开pdb调试环境，即使该程序当前不处于调试状态。

3）使用命令行调试程序

在命令行提示符下执行“python –m pdb 脚本文件名”，则直接进入调试环境；当调试结束或程序正常结束以后，pdb将重启该程序。

8.4 Python内建异常类的基类是          。（BaseException）

8.5 断言语句的语法为               。（assert expression, ‘error information’）

8.6 Python上下文管理语句是            。（with）



第9章 GUI编程

9.1 设计一个窗体，并放置一个按钮，单击按钮后弹出颜色对话框，关闭颜色对话框后提示选中的颜色。

答：

（1）wxPython版，需要安装phoenix

import wx



class wxGUI(wx.App):

​    def OnInit(self):

​        frame = wx.Frame(parent=None, title='wxGUI', size=(160,140))

​        panel = wx.Panel(frame, -1)        

​        buttonOK = wx.Button(panel, -1, 'OK', pos=(0,0))

​        self.Bind(wx.EVT_BUTTON, self.OnButtonOK, buttonOK)

​        frame.Show()

​        return True

​    def OnButtonOK(self, event):

​        colorDlg = wx.ColourDialog(None)

​        colorDlg.ShowModal()

​        color = colorDlg.GetColourData().Colour

​        wx.MessageBox(str(color))

app = wxGUI()

app.MainLoop()

（2）tkinter版

import tkinter

import tkinter.colorchooser

import tkinter.messagebox



root = [http://tkinter.Tk()](https://link.zhihu.com/?target=http%3A//tkinter.Tk())



def onBtnColorClick():

​    color = tkinter.colorchooser.askcolor()[1]

​    if color:

​        tkinter.messagebox.showinfo('', str(color))

btnColor = tkinter.Button(root, text='colorChooser', command=onBtnColorClick)

btnColor.place(x=10, y=10, width=100, height=20)



root.mainloop()

9.2 设计一个窗体，并放置一个按钮，按钮默认文本为“开始”，单击按钮后文本变为“结束”，再次单击后变为“开始”，循环切换。

答：

（1）wxPython版

import wx



class wxGUI(wx.App):

​    def OnInit(self):

​        frame = wx.Frame(parent=None, title='wxGUI', size=(160,140))

​        panel = wx.Panel(frame, -1)        

​        self.buttonOK = wx.Button(panel, -1, 'Start', pos=(0,0))

​        self.Bind(wx.EVT_BUTTON, self.OnButtonOK, self.buttonOK)

​        frame.Show()

​        return True

​    def OnButtonOK(self, event):

​        text = self.buttonOK.GetLabelText()

​        if text == 'Start':

​            self.buttonOK.SetLabelText('End')

​        elif text == 'End':

​            self.buttonOK.SetLabelText('Start')

app = wxGUI()

app.MainLoop()

（2）tkinter版

import tkinter

import tkinter.colorchooser

import tkinter.messagebox



root = [http://tkinter.Tk()](https://link.zhihu.com/?target=http%3A//tkinter.Tk())



def onBtnChangeClick():

​    if btnChange['text'] == '开始':

​        btnChange['text'] = '结束'

​    elif btnChange['text'] == '结束':

​        btnChange['text'] = '开始'

btnChange = tkinter.Button(root, text='开始', command=onBtnChangeClick)

btnChange.place(x=10, y=10, width=100, height=20)



root.mainloop()

9.3 设计一个窗体，模拟QQ登录界面，当用户输入号码123456和密码654321时提示正确，否则提示错误。

答：

（1）wxPython版

import wx



class wxGUI(wx.App):

​    def OnInit(self):

​        frame = wx.Frame(parent=None,

​                         title='Login',

​                         size=(250,150),

​                         pos=(350,350))

​        panel = wx.Panel(frame, -1)



​        label1 = wx.StaticText(panel,

​                               -1,

​                               'UserName:',

​                               pos=(0,10),

​                               style=wx.ALIGN_RIGHT)

​        label2 = wx.StaticText(panel,

​                               -1,

​                               'Password:',

​                               pos=(0,30),

​                               style=wx.ALIGN_RIGHT)



​        self.textName = wx.TextCtrl(panel,

​                                    -1,

​                                    pos=(70,10),

​                                    size=(160,20))

​        self.textPwd = wx.TextCtrl(panel,

​                                   -1,

​                                   pos=(70,30),

​                                   size=(160,20),

​                                   style=wx.TE_PASSWORD)

​        buttonOK = wx.Button(panel, -1, 'OK', pos=(30,60))

​        self.Bind(wx.EVT_BUTTON, self.OnButtonOK, buttonOK)

​        buttonCancel = wx.Button(panel, -1, 'Cancel', pos=(120,60))

​        self.Bind(wx.EVT_BUTTON, self.OnButtonCancel, buttonCancel)

​        buttonOK.SetDefault()



​        frame.Show()

​        return True

​    def OnButtonOK(self, event):

​        usrName = self.textName.GetValue()

​        usrPwd = self.textPwd.GetValue()

​        if usrName=='123456' and usrPwd=='654321':

​            wx.MessageBox('Right')

​        else:

​            wx.MessageBox('Wrong')

​    def OnButtonCancel(self, event):

​        pass

app = wxGUI()

app.MainLoop()

（2）tkinter版

import tkinter

import tkinter.messagebox



\# 创建应用程序窗口

root = [http://tkinter.Tk()](https://link.zhihu.com/?target=http%3A//tkinter.Tk())



\# 在窗口上创建标签组件

labelName = tkinter.Label(root,\

​                          text='User Name:',\

​                          justify=tkinter.RIGHT,\

​                          anchor = 'e',\

​                          width=80)

labelName.place(x=10, y=5, width=80, height=20)



\# 创建字符串变量和文本框组件，同时设置关联的变量

varName = tkinter.StringVar(root, value='')

entryName = tkinter.Entry(root,\

​                          width=80,\

​                          textvariable=varName)

entryName.place(x=100, y=5, width=80, height=20)



labelPwd = tkinter.Label(root,\

​                         text='User Pwd:',\

​                         justify=tkinter.RIGHT,\

​                         anchor = 'e',\

​                         width=80)

labelPwd.place(x=10, y=30, width=80, height=20)



\# 创建密码文本框

varPwd = tkinter.StringVar(root, value='')

entryPwd = tkinter.Entry(root,\

​                         show='*',\

​                         width=80,\

​                         textvariable=varPwd)

entryPwd.place(x=100, y=30, width=80, height=20)



\# 登录按钮事件处理函数

def login():

​    \# 获取用户名和密码

​    name = entryName.get()

​    pwd = entryPwd.get()

​    if name=='123456' and pwd=='654321':

​        tkinter.messagebox.showinfo(title='恭喜',\

​                                    message='登录成功！')

​    else:

​        tkinter.messagebox.showerror('警告',\

​                                     message='用户名或密码错误')

\# 创建按钮组件，同时设置按钮事件处理函数

buttonOk = tkinter.Button(root,\

​                          text='Login',\

​                          command=login)

buttonOk.place(x=30, y=70, width=50, height=20)



\# 取消按钮的事件处理函数

def cancel():

​    \#清空用户输入的用户名和密码

​    varName.set('')

​    varPwd.set('')

buttonCancel = tkinter.Button(root,\

​                              text='Cancel',\

​                              command=cancel)

buttonCancel.place(x=90, y=70, width=50, height=20)



\#启动消息循环

root.mainloop()





第10章 网络程序设计

10.1 简单解释TCP和UDP协议的区别。

答：

TCP协议是面向连接的、具有质量保证的可靠传输协议，但开销较大；UDP协议是尽最大能力传输的无连接协议，开销小，常用于视频在线点播（Video On Demand, VOD）之类的应用。TCP协议和UDP协议并没有优劣之分，仅仅是适用场合有所不同。

10.2 同学之间合作编写UDP通信程序，分别编写发送端和接收端代码，发送端发送一个字符串“Hello world!”。假设接收端在计算机的5000端口进行接收，并显示接收内容。

答：首先使用ipconfig/all命令查看本机IP地址，然后分别编写下面的代码，并将其中的IP地址替换为相应的IP地址。

接收端代码： 

import socket



s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) 

s.bind(("", 5000))                             # 空字符串表示本机任何可用IP地址

data, addr = s.recvfrom(1024)                   # 缓冲区大小为1024字节

print(' received message:%s' % data.decode())      # 显示接收到的内容

s.close( )



发送端代码：

import socket



s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

\# 把127.0.0.1替换为对方同学计算机的IP地址

s.sendto("Hello, world!".encode() , ("127.0.0.1" ,5000))

s.close( )

10.3 简单介绍socket模块中用于TCP编程的常用方法。

TCP一般用于要求可靠数据传输的场合。编写TCP程序时经常需要用到的socket模块方法主要有：

connect(address)：连接远程计算机

send(bytes[,flags])：发送数据

recv(bufsize[,flags])：接收数据

bind(address)：绑定地址

listen(backlog)：开始监听，等待客户端连接

accept()：响应客户端的请求

10.4 编写代码读取搜狐网页首页内容。

答：

import urllib.request



dir(urllib.request)

fp = urllib.request.urlopen('[http://www.sohu.com.cn](https://link.zhihu.com/?target=http%3A//www.sohu.com.cn)')

print(fp.read(100))

fp.close()

10.5 在自己的机器上配置IIS以支持Python脚本的运行，然后使用Python编写脚本，运行后在网页上显示“Hello world!”。

答：核心代码为

print('Status: 200 OK')

print('Content-type: text/html')

print('')

print('<HTML><HEAD><TITLE>Python Sample CGI</TITLE></HEAD>')

print('<BODY>')

print('<H1>This is a header</H1>')

print('<p>Hello world!')

print('<br>')

print('</BODY></HTML>')





第11章 大数据处理

11.1 简单介绍常见的大数据处理框架。

答：主要有三种，

MapReduce：分布式计算框架，可以将单个大型计算作业分配给多台计算机执行，可以在短时间内完成大量工作，尤其适合数值型和标称型数据，但需要对行业领域具有一定理解后重写算法来完成特定的业务处理要求。MapReduce的名字由函数式编程中常用的map和reduce两个单词组成。MapReduce在大量节点组成的集群上运行，工作流程是：单个作业被分成很多小份，输入数据也被切片并分发到每个节点，每个节点只在本地数据上做运算，对应的运算代码称为mapper，这个过程即map阶段；每个mapper的输出通过某种方式组合，根据需要可能再进行重新排序，排序后的结果再被切分成小份并分发到各个节点进行下一步处理，这个过程被称为reduce阶段，对应的代码称为reducer。不同类型的作业可能需要不同数量的reducer，并且，在任何时候，每个mapper或reducer之间都不进行通信，每个节点只负责处理自己的事务，并且只在分配到本地的数据集上进行运算。

Hadoop：Hadoop是MapReduce框架的一个免费开源实现，采用Java语言编写，支持在大量机器上分布式处理数据。除了分布式计算之外，Hadoop还自带分布式文件系统，可以在上面运行多种不同语言编写的分布式程序。Hadoop在可伸缩性、健壮性、计算性能和成本上具有无可替代的优势，事实上已成为当前互联网企业主流的大数据分析平台。

Spark：Spark是一个针对超大数据集合的低延迟集群分布式计算系统，比MapReduce快40倍左右。Spark是Hadoop的升级版本，兼容Hadoop的API，能够读写Hadoop的HDFS HBASE 顺序文件等，与之不同的是将结果保存在内存中。 Hadoop作为第一代产品使用了HDFS，第二代加入了Cache来保存中间计算结果，第三代则是Spark倡导的流技术Streaming。

11.2 运行本章中代码并理解MapReduce编程思路。

答：略



第12章 Windows系统编程

12.1 查阅相关资料，解释注册表几大根键的用途。

答：略

12.2 选择一个编写好的Python程序，将其转换为exe可执行文件。

答：略，请参考书中相关介绍。

12.3 编写代码，使用至少3中不同的方法启动Windows自带的计算器程序。

答：

第一种方法：

\>>> import os

\>>> os.system('calc.exe')

第二种方法：

\>>> import os

\>>> os.popen('calc.exe')

第三种方法：

\>>> import os

\>>> os.startfile('calc.exe')

第四种方法：

\>>> import win32api

\>>> win32api.ShellExecute(0, 'open', 'calc.exe', '', '', 1)

第五种方法：

\>>> import win32process

\>>> handle=win32process.CreateProcess(r'c:\windows\system32\calc.exe','', None,None,0, win32process.CREATE_NO_WINDOW, None, None,win32process.STARTUPINFO())

12.4 编写代码，检测您所使用的操作系统版本。

答：略，请参考12.5节。



第13章 多线程编程

13.1  简单叙述创建线程的方法。

答：

Thread类支持使用两种方法来创建线程，一种是为构造函数传递一个可调用对象，另一种是继承Thread类并在派生类中重写__init__()和run()方法。创建了线程对象以后，可以调用其start()方法来启动，该方法自动调用该类对象的run()方法，此时该线程处于alive状态，直至线程的run()方法运行结束。

13.2  简单叙述Thread对象的方法。

答：

（1）join([timeout]：阻塞当前线程，等待被调线程结束或超时后再继续执行当前线程的后续代码，参数timeout用来指定最长等待时间，单位为秒。

（2）isAlive()：测试线程是否处于运行状态

（3）start()：自动调用run()方法，启动线程，执行线程代码。

（4）run()：线程代码，用来实现线程的功能与业务逻辑，可以在子类中重写该方法来自定义线程的行为。

13.3  简单叙述线程对象的daemon属性的作用和影响。

答：

在脚本运行过程中有一个主线程，若在主线程中创建了子线程，当主线程结束时根据子线程daemon属性值的不同可能会发生下面的两种情况之一：1）当某子线程的daemon属性为False时，主线程结束时会检测该子线程是否结束，如果该子线程尚未完成，则主线程会等待它完成后再退出；2）当某子线程的daemon属性为True时，主线程运行结束时不对该子线程进行检查而直接退出，同时所有daemon值为True的子线程将随主线程一起结束，而不论是否运行完成。daemon属性的值默认为False，如果需要修改，则必须在调用start()方法启动线程之前进行修改。

13.4  解释至少3种线程同步方法。

答：

使用Condition对象可以在某些事件触发后才处理数据，可以用于不同线程之间的通信或通知，以实现更高级别的同步。Condition对象除了具有acquire()和release()方法之外，还有wait()、notify()、notify_all()等方法。下面通过经典生产者/消费者问题来演示Condition对象的用法。

Queue模块（在Python 3中为queue模块）实现了多生产者/多消费者队列，尤其适合需要在多个线程之间进行信息交换的场合，该模块的Queue对象实现了多线程编程所需要的所有锁语义。

Event对象是一种简单的线程通信技术，一个线程设置Event对象，另一个线程等待Event对象。Event对象的set()方法可以设置Event对象内部的信号标志为真；clear()方法可以清除Event对象内部的信号标志，将其设置为假；isSet()方法用来判断其内部信号标志的状态；wait()方法只有在其内部信号状态为真时将很快地执行并返回，若Event对象的内部信号标志为假，wait()方法将一直等待至超时或内部信号状态为真。



第14章 数据库编程

14.1  简单介绍SQLite数据库。

答：

SQLite是内嵌在Python中的轻量级、基于磁盘文件的数据库管理系统，不需要服务器进程，支持使用SQL语句来访问数据库。该数据库使用C语言开发，支持大多数SQL91标准，支持原子的、一致的、独立的和持久的事务，不支持外键限制；通过数据库级的独占性和共享锁定来实现独立事务，当多个线程同时访问同一个数据库并试图写入数据时，每一时刻只有一个线程可以写入数据。SQLite支持超过2TB大小的单个数据库，每个数据库完全存储在单个磁盘文件中，以B+树数据结构的形式存储，一个数据库就是一个文件，通过简单复制即可实现数据库的备份。

14.2  使用Python内置函数dir()查看Cursor对象中的方法，并使用内置函数help()查看其用法。

答：略。

14.3 叙述使用Python操作Access数据库的步骤。

答：

（1）建立数据库连接

import win32com.client   

conn = win32com.client.Dispatch(r'ADODB.Connection')   

DSN = 'PROVIDER=Microsoft.Jet.OLEDB.4.0;DATA SOURCE=C:/MyDB.mdb;'   

conn.Open(DSN)

（2）打开记录集

rs = win32com.client.Dispatch(r'ADODB.Recordset')   

rs_name = 'MyRecordset' #表名   

rs.Open('[' + rs_name + ']', conn, 1, 3)

（3）操作记录集

rs.AddNew()   

rs.Fields.Item(1).Value = 'data'   

rs.Update()

（4）操作数据

conn = win32com.client.Dispatch(r'ADODB.Connection')   

DSN = 'PROVIDER=Microsoft.Jet.OLEDB.4.0;DATA SOURCE=C:/MyDB.mdb;'   

sql_statement = "Insert INTO [Table_Name] ([Field_1], [Field_2]) VALUES ('data1', 'data2')" 

conn.Open(DSN)   

conn.Execute(sql_statement)   

conn.Close()

（5）遍历记录

rs.MoveFirst()   

count = 0   

while 1:   

​    if rs.EOF:   

​        break   

​    else:   

​        count = count + 1   

​    rs.MoveNext()

14.4  叙述使用Python操作MS SQL Server数据库的步骤。

答：

可以使用pywin32和pymssql两种不同的方式来访问MS SQL Server数据库。

先来了解一下pywin32模块访问MS SQL Server数据库的步骤。

（1）添加引用:

import adodbapi

adodbapi.adodbapi.verbose = False # adds details to the sample printout

import adodbapi.ado_consts as adc

（2）创建连接:

Cfg = {'server':'192.168.29.86\\eclexpress','password':'xxxx','db':'pscitemp'}

constr = r"Provider=SQLOLEDB.1; Initial Catalog=%s; Data Source=%s; user ID=%s; Password=%s; "% (Cfg['db'], Cfg['server'], 'sa', Cfg['password'])

conn = adodbapi.connect(constr)

（3）执行sql语句:

cur = conn.cursor()

sql = '''select * from softextBook where title='{0}' and remark3!='{1}''''.format(bookName,flag)

cur.execute(sql)

data = cur.fetchall()

cur.close()

（4）执行存储过程:

\#假设proName有三个参数,最后一个参数传了null

ret = cur.callproc('procName',(parm1,parm2,None))

conn.commit()

（5）关闭连接

conn.close()

接下来再通过一个示例来简单了解一下使用pymssql模块访问MS SQL Server数据库的方法。

import pymssql  

conn = pymssql.connect(host='SQL01', user='user', password='password', database='mydatabase')  

cur = conn.cursor()  

cur.execute('CREATE TABLE persons(id INT, name VARCHAR(100))')  

cur.executemany("INSERT INTO persons VALUES(%d, xinos.king)", [ (1, 'John Doe'), (2, 'Jane Doe') ])  

conn.commit() 

cur.execute('SELECT * FROM persons WHERE salesrep=xinos.king', 'John Doe')

row = cur.fetchone()  

while row:  

​    print "ID=%d, Name=xinos.king" % (row[0], row[1])  

​    row = cur.fetchone()  

cur.execute("SELECT * FROM persons WHERE salesrep LIKE 'J%'")  

conn.close()

14.5  叙述MySQLDb模块提供的数据库访问方法。

答：

Python访问MySQL数据库可以使用MySQLDb模块，该模块主要方法有：

commit() ：提交事务。

rollback() ：回滚事务。

callproc(self, procname, args)：用来执行存储过程，接收的参数为存储过程名和参数列表，返回值为受影响的行数。

execute(self, query, args)：执行单条sql语句，接收的参数为sql语句本身和使用的参数列表，返回值为受影响的行数。

executemany(self, query, args)：执行单条sql语句，但是重复执行参数列表里的参数，返回值为受影响的行数。

nextset(self)：移动到下一个结果集。

fetchall(self)：接收全部的返回结果行。

fetchmany(self, size=None)：接收size条返回结果行，如果size的值大于返回的结果行的数量，则会返回cursor.arraysize条数据。

fetchone(self)：返回一条结果行。

scroll(self, value, mode='relative')：移动指针到某一行，如果mode='relative'，则表示从当前所在行移动value条；如果 mode='absolute'，则表示从结果集的第一行移动value条。



第15章 多媒体编程

15.1  编程程序，在窗口上绘制一个三角形，设置三个顶点为不同的颜色，并对内部进行光滑着色。

答：

from OpenGL.GL import *

from OpenGL.GLUT import *

from OpenGL.GLU import *

import sys



class MyPyOpenGLTest:

​    def __init__(self, width = 640, height = 480, title =b 'MyPyOpenGLTest'):

​        glutInit(sys.argv)

​        glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH)

​        glutInitWindowSize(width, height)

​        self.window = glutCreateWindow(title)

​        glutDisplayFunc(self.Draw)

​        glutIdleFunc(self.Draw)

​        self.InitGL(width, height)



​    \#default drawing function

​    def Draw(self):

​        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

​        glLoadIdentity()

​        glTranslatef(-2.0, 0.0, -8.0)

​        \#draw 2D graphic, leaving z to be 0

​        glBegin(GL_POLYGON)

​        glColor3f(1.0, 0.0, 0.0)

​        glVertex3f(0.0, 1.0, 0.0)

​        glColor3f(0.0, 1.0, 0.0)

​        glVertex3f(1.0, -1.0, 0.0)

​        glColor3f(0.0, 0.0, 1.0)

​        glVertex3f(-1.0, -1.0, 0.0)

​        glEnd()

​        glTranslatef(2.5, 0.0, 0.0)

​        glutSwapBuffers()

​    def InitGL(self, width, height):

​        glClearColor(0.0, 0.0, 0.0, 0.0)

​        glClearDepth(1.0)

​        glDepthFunc(GL_LESS)

​        glShadeModel(GL_SMOOTH)

​        glEnable(GL_POINT_SMOOTH)

​        glEnable(GL_LINE_SMOOTH)

​        glEnable(GL_POLYGON_SMOOTH)

​        glMatrixMode(GL_PROJECTION)

​        glHint(GL_POINT_SMOOTH_HINT,GL_NICEST)

​        glHint(GL_LINE_SMOOTH_HINT,GL_NICEST)

​        glHint(GL_POLYGON_SMOOTH_HINT,GL_FASTEST)

​        glLoadIdentity()

​        gluPerspective(45.0, float(width)/float(height), 0.1, 100.0)

​        glMatrixMode(GL_MODELVIEW)

​    def MainLoop(self):

​        glutMainLoop()



if __name__ == '__main__':

​    w = MyPyOpenGLTest()

​    w.MainLoop()

15.2  编写程序，读取两幅大小一样的图片，然后将两幅图像的内容叠加到一幅图像，结果图像中每个像素值为原两幅图像对应位置像素值的平均值。

答：

from PIL import Image



im1 = Image.open('d:\\pic1.bmp')

im2 = Image.open('d:\\pic2.bmp')

size = im1.size



for i in range(size[0]):

​    for j in range(size[1]):

​        color1 = im1.getpixel((i,j))

​        color2 = im2.getpixel((i,j))

​        r = (color1[0]+color2[0])//2

​        g = (color1[1]+color2[1])//2

​        b = (color1[2]+color2[2])//2

​        im1.putpixel((i,j),(r,g,b))



im1.save('d:\\pic3.bmp')

im1.close()

im2.close()

15.3  编写程序，读取一幅图像的内容，将其按象限分为4等份，然后1、3象限内容交换，2、4象限内容交换，生成一幅新图像。

答：

from PIL import Image



im = Image.open('test.bmp')

size = im.size



box1 = (0, size[1]//2, size[0]//2, size[1])

region1 = im.crop(box1)

box2 = (0, 0, size[0]//2, size[1]//2)

region2 = im.crop(box2)

box3 = (size[0]//2, 0, size[0], size[1]//2)

region3 = im.crop(box3)

box4 = (size[0]//2, size[1]//2, size[0], size[1])

region4 = im.crop(box4)



im.paste(region1, box3)

im.paste(region3, box1)

im.paste(region2, box4)

im.paste(region4, box2)



im.save('result.bmp')

im.close()

15.4  结合GUI编程知识，编写一个程序，创建一个窗口并在上面放置两个按钮，分别为“开始播放”和“暂停播放”，将本章15.3节中的音乐播放程序进行封装。

答：

（1）wxPython版

import wx

import os

import pygame

import random

import time

import threading



class wxGUI(wx.App):

​    def OnInit(self):

​        frame = wx.Frame(parent=None, title='MP3Player', size=(250,150), pos=(350,350))

​        panel = wx.Panel(frame, -1)

​        self.buttonOK = wx.Button(panel, -1, 'Play', pos=(30,60))

​        self.Bind(wx.EVT_BUTTON, self.OnButtonOK, self.buttonOK)

​        self.buttonOK.Enabled = True

​        self.buttonCancel = wx.Button(panel, -1, 'Stop', pos=(120,60))

​        self.Bind(wx.EVT_BUTTON, self.OnButtonCancel, self.buttonCancel)

​        self.buttonCancel.Enabled = False



​        frame.Show()

​        return True



​    def OnExit(self):

​        try:

​            self.playing = False

​            pygame.mixer.music.stop()

​        finally:

​            pass

​    def play(self):

​        folder = r'h:\music'

​        musics = [folder+'\\'+music for music in os.listdir(folder) if music.endswith('.mp3')]

​        total = len(musics)

​        pygame.mixer.init()

​        while self.playing:

​            if not pygame.mixer.music.get_busy():

​                nextMusic = random.choice(musics)

​                pygame.mixer.music.load(nextMusic)

​                pygame.mixer.music.play(1)

​                print 'playing....',nextMusic

​            else:

​                time.sleep(1)



​    def OnButtonOK(self, event):

​        self.playing = True

​        \# create a new thread to play music

​        t = threading.Thread(target=self.play)

​        t.start()

​        self.buttonOK.Enabled = False

​        self.buttonCancel.Enabled = True        

​    def OnButtonCancel(self, event):

​        self.playing = False

​        pygame.mixer.music.stop()

​        self.buttonOK.Enabled = True

​        self.buttonCancel.Enabled = False

app = wxGUI()

app.MainLoop()

（2）tkinter版

import os

import tkinter

import tkinter.filedialog

import random

import time

import threading

import pygame



folder = ''



def play():

​    \# folder用来表示存放MP3音乐文件的文件夹

​    global folder

​    musics = [folder+'\\'+music

​              for music in os.listdir(folder) \

​              if music.endswith(('.mp3', '.wav', '.ogg'))]

​    \# 初始化混音器设备

​    pygame.mixer.init()

​    while playing:

​        if not pygame.mixer.music.get_busy():

​            \# 随机播放一首歌曲

​            nextMusic = random.choice(musics)

​            pygame.mixer.music.load(nextMusic.encode())

​            \# 播放一次

​            pygame.mixer.music.play(1)

​            musicName.set('playing....'+nextMusic)

​        else:

​            time.sleep(0.3)

root = [http://tkinter.Tk()](https://link.zhihu.com/?target=http%3A//tkinter.Tk())

root.title('音乐播放器v1.0---董付国')

root.geometry('280x70+400+300')

root.resizable(False, False)



\# 关闭程序时执行的代码

def closeWindow():

​    \# 修改变量，结束线程中的循环

​    global playing

​    playing = False

​    time.sleep(0.3)

​    try:

​        \# 停止播放，如果已停止，

​        \# 再次停止时会抛出异常，所以放在异常处理结构中

​        pygame.mixer.music.stop()

​        pygame.mixer.quit()

​    except:

​        pass

​    root.destroy()

root.protocol('WM_DELETE_WINDOW', closeWindow)



pause_resume = tkinter.StringVar(root, value='NotSet')

playing = False



\# 播放按钮

def buttonPlayClick():

​    \# 选择要播放的音乐文件夹

​    global folder

​    if not folder:

​        folder = tkinter.filedialog.askdirectory()

​    if not folder:

​        return

​    global playing

​    playing = True

​    \# 创建一个线程来播放音乐，当前主线程用来接收用户操作

​    t = threading.Thread(target=play)

​    t.start()

​    \# 根据情况禁用和启用相应的按钮

​    buttonPlay['state'] = 'disabled'

​    buttonStop['state'] = 'normal'

​    buttonPause['state'] = 'normal'    

​    buttonNext['state'] = 'normal'

​    pause_resume.set('Pause')

buttonPlay = tkinter.Button(root,

​                            text='Play',

​                            command=buttonPlayClick)

buttonPlay.place(x=20, y=10, width=50, height=20)



\# 停止按钮

def buttonStopClick():

​    global playing

​    playing = False

​    pygame.mixer.music.stop()

​    musicName.set('暂时没有播放音乐')



​    buttonPlay['state'] = 'normal'

​    buttonStop['state'] = 'disabled'

​    buttonPause['state'] = 'disabled'

​    buttonNext['state'] = 'disabled'

​    global folder

​    folder = ''

buttonStop = tkinter.Button(root,

​                            text='Stop',

​                            command=buttonStopClick)

buttonStop.place(x=80, y=10, width=50, height=20)

buttonStop['state'] = 'disabled'



\# 暂停与恢复，两个功能共用一个按钮

def buttonPauseClick():

​    \# global playing

​    if pause_resume.get() == 'Pause':

​        pygame.mixer.music.pause()

​        pause_resume.set('Resume')

​    elif pause_resume.get() == 'Resume':

​        pygame.mixer.music.unpause()

​        pause_resume.set('Pause')

buttonPause = tkinter.Button(root,

​                             textvariable=pause_resume,

​                             command=buttonPauseClick)

buttonPause.place(x=140, y=10, width=50, height=20)

buttonPause['state'] = 'disabled'



\# 下一首音乐

def buttonNextClick():

​    global playing

​    playing = False

​    pygame.mixer.music.stop()

​    pygame.mixer.quit()

​    buttonPlayClick()

buttonNext = tkinter.Button(root,

​                            text='Next',

​                            command=buttonNextClick)

buttonNext.place(x=200, y=10, width=50, height=20)

buttonNext['state'] = 'disabled'



musicName = tkinter.StringVar(root,

​                              value='暂时没有播放音乐...')

labelName = tkinter.Label(root,

​                          textvariable=musicName)

labelName.place(x=0, y=40, width=270, height=20)



\# 启动消息循环

root.mainloop()



15.5  运行本章15.4中的代码并查看运行结果。

答：略。



第16章 逆向工程与软件分析

16.1  下载PE文件规范8.3版本，并尝试了解PE文件基本结构。

答：略。

16.2  下载并安装IDA Pro与Immunity Debugger，并简单了解PE文件反汇编和调试步骤。

答：略。

16.3  安装并配置IDAPython插件，然后运行本章16.2.1小节的Python代码。

答：略。

16.4  在Immunity Debugger调试器中运行本章16.2.2小节中的代码。

答：略。

16.5  叙述软件调试断点的概念、作用及其分类。

答：

断点是最常用的软件调试技术之一，其基本思想是在某一个位置设置一个“陷阱”，当CPU执行到这个位置的时候停止被调试的程序并中断到调试器中，让调试者进行分析和调试，调试者分析结束后，可以让被调试程序恢复执行。通过设置断点可以暂停程序执行，并可以观察和记录指令信息、变量值、堆栈参数和内存数据，还可以深入了解和把握程序执行的内部原理和详细过程，断点对于软件调试具有重要的意义和作用。

断点可以分为软件断点、硬件断点和内存断点三大类。

1）软件断点

软件断点是一个单字节指令（INT 3，字节码为0xCC），可以在程序中设置多个软件断点，使得程序执行到该处时能够暂停执行，并将控制权转移给调试器的断点处理函数。

当调试器被告知在目标地址设置一个断点，它首先读取目标地址的第一个字节的操作码，然后保存起来，同时把地址存储在内部的中断列表中。接着，调试器把一个字节操作码 “0xCC” 写入刚才的地址。当 CPU 执行到“0xCC”操作码的时候就会触发一个 “INT 3”中断事件，此时调试器就能捕捉到这个事件。调试器继续判断这个发生中断事件的地址(通过指令指针寄存器EIP)是不是自己先前设置断点的地址。如果在调试器内部的断点列表中找到了这个地址，就将设置断点前存储起来的操作码写回到目标地址，这样进程被调试器恢复后就能正常的执行。

2）硬件断点

硬件断点通过调试寄存器实现，设置在CPU级别上，当需要调试某个指定区域而又无法修改该区域时，硬件断点非常有用。

 一个CPU一般会有8 个调试寄存器（DR0 寄存器到DR7寄存器），用于管理硬件断点。其中调试寄存器DR0到调试寄存器DR3存储硬件断点地址，同一时间内最多只能设置4个硬件断点；DR4和DR5保留，DR6是状态寄存器，说明被断点触发的调试事件的类型；DR7本质上是一个硬件断点的开关寄存器，同时也存储了断点的不同类型。通过在DR7寄存器里设置不同标志，能够创建以下几种断点：当特定的地址上有指令执行的时候中断、当特定的地址上有数据写入的时候、当特定的地址上有数据读或者写但不执行的时候。

硬件断点使用“INT 1”实现，该中断负责硬件中断和步进事件。步进是指根据预定的流程一条一条地执行指令，每执行完一条指令后暂停下来，从而可以精确地观察关键代码并监视寄存器和内存数据的变化。在CPU每次执行代码之前，都会先确认当前将要执行代码的地址是否是硬件断点的地址，同时也要确认是否有代码要访问被设置了硬件断点的内存区域。如果任何储存在DR0-DR3中的地址所指向的区域被访问了，就会触发 “INT 1”中断，同时暂停CPU；如果不是中断地址则CPU执行该行代码，到下一行代码时，CPU继续重复上面的过程。

3）内存断点

内存断点是通过修改内存中指定块或页的访问权限来实现的。通过将指定内存块或页的访问权限属性设置为受保护的，则任何不符合访问权限约束的操作都将失败，并抛出异常，导致CPU暂停执行，使得调试器可以查看当前执行状态。

一般来说，每个内存块或页的访问权限都由三种不同的访问权限组成：是否可执行、是否可读、是否可写。每个操作系统都提供了用来查询和修改内存页访问权限的函数，在Windows操作系统中可以使用VirtualProtect()函数来修改主调进程虚拟地址空间中已提交页面的保护属性，使用VirtualProtectEx()函数可以修改其他进程虚拟地址空间页面的保护属性。

16.6  运行本章16.4节中的代码并查看运行结果。

答：略。



第17章 科学计算与可视化

17.1  运行本章所有代码并查看运行结果。

答：略。

17.2  使用Python内置函数dir()查看scipy模块中的对象与方法，并使用Python内置函数help()查看其使用说明。

答：略。



第18章  密码学编程

18.1  根据安全哈希值可以还原原始的消息内容（判断题，对或错）。（错）

18.2  RSA算法的安全性主要取决于密钥的长度（判断题，对或错）。（对）

18.3  查看Python扩展库pycrypto文件夹结构，了解其提供的各种模块和库。

略



第19章  安卓平台的Python编程

19.1  查阅资料，了解androidhelper、android、sl4a这3个包的异同。